name: Auto-label issues from QA issue form (authoritative + no-op when unchanged)

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  issues: write

# Prevent overlapping runs for the same issue (acts like a debounce)
concurrency:
  group: issue-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  auto_label:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.issue.number;
            const body = context.payload.issue.body || "";

            // If this was an edit but the body didn't change, skip.
            // (Prevents relabeling on title/assignee/milestone-only edits, etc.)
            if (
              context.payload.action === "edited" &&
              !context.payload.changes?.body
            ) {
              core.info("Issue edited but body did not change. Skipping.");
              return;
            }

            // ---------------- helpers ----------------
            function escapeRegExp(s) {
              return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            }

            function getSection(sectionTitle) {
              const re = new RegExp(
                `^###\\s+${escapeRegExp(sectionTitle)}\\s*\\n+([\\s\\S]*?)(?=\\n###\\s+|\\n$)`,
                "m"
              );
              const m = body.match(re);
              return m ? m[1].trim() : null;
            }

            function getCheckedOptions(sectionTitle) {
              const block = getSection(sectionTitle);
              if (!block) return [];
              return block
                .split("\n")
                .map(l => l.trim())
                .filter(l => l.startsWith("- [x] "))
                .map(l => l.replace("- [x] ", "").trim());
            }

            async function ensureLabel(name) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name,
                    color: "c5def5",
                    description: "Auto-applied from issue form"
                  });
                } else {
                  throw e;
                }
              }
            }

            // ---------------- read form values ----------------
            const qaCategory = getSection("QA Category");      // dropdown
            const devices = getCheckedOptions("Device(s)");   // checkboxes
            const browsers = getCheckedOptions("Browser(s)"); // checkboxes
            const issueType = getSection("Issue Type"); // dropdown

            // ---------------- mappings ----------------
            const qaMap = {
              "Functionality Testing": "qa:functionality",
              "Responsive and Cross-browser Testing": "qa:responsive-crossbrowser",
              "Accessibility": "qa:accessibility",
              "Load Testing": "qa:load"
            };

            const deviceMap = {
              "Mac Desktop / Laptop": "device:mac",
              "Windows Desktop / Laptop": "device:windows",
              "iPhone": "device:iphone",
              "Android Phone": "device:android-phone",
              "iPad": "device:ipad",
              "Android Tablet": "device:android-tablet"
            };

            const browserMap = {
              "Chrome": "browser:chrome",
              "Edge": "browser:edge",
              "Firefox": "browser:firefox",
              "Safari": "browser:safari"
            };

            const issueTypeMap = {
              "Breaking Functionality (Didn't Work At All!)": "issue:breaking functionality",
              "Functional Deviation (Didn't Work as Expected!)": "issue:functional deviation",
              "Visual / Design (Didn't Look Right!)": "issue:visual / design",
              "Copy / Content (The Words Are Wrong!)": "issue:copy / content"
            };

            const desired = new Set();

            if (qaCategory && qaMap[qaCategory]) desired.add(qaMap[qaCategory]);
            devices.forEach(d => { if (deviceMap[d]) desired.add(deviceMap[d]); });
            browsers.forEach(b => { if (browserMap[b]) desired.add(browserMap[b]); });

            const desiredLabels = Array.from(desired);

            const prefixes = ["qa:", "device:", "browser:"];

            // Safety: if we can't parse anything, do nothing.
            // (Avoid wiping labels when headings don't match.)
            if (desiredLabels.length === 0) {
              core.warning("No desired labels found (check section titles). Skipping.");
              return;
            }

            // ---------------- no-op if unchanged ----------------
            const currentScoped = (context.payload.issue.labels || [])
              .map(l => l.name)
              .filter(name => prefixes.some(p => name.startsWith(p)))
              .sort();

            const desiredScoped = desiredLabels.slice().sort();

            if (JSON.stringify(currentScoped) === JSON.stringify(desiredScoped)) {
              core.info("Scoped labels already correct. No changes needed.");
              return;
            }

            // ---------------- authoritative mode ----------------
            // Remove existing scoped labels, then apply desired scoped labels.
            const toRemove = currentScoped;

            for (const name of toRemove) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number, name });
              } catch (e) {
                if (e.status !== 404) throw e;
              }
            }

            // Ensure labels exist
            for (const l of desiredLabels) await ensureLabel(l);

            // Apply desired labels
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number,
              labels: desiredLabels
            });

            core.info(`Removed scoped labels: ${toRemove.join(", ") || "(none)"}`);
            core.info(`Applied labels: ${desiredLabels.join(", ")}`);
