name: Auto-label issues from QA issue form (authoritative)

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  issues: write

jobs:
  auto_label:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.issue.number;
            const body = context.payload.issue.body || "";

            // ---------------- helpers ----------------
            function escapeRegExp(s) {
              return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            }

            function getSection(sectionTitle) {
              const re = new RegExp(
                `^###\\s+${escapeRegExp(sectionTitle)}\\s*\\n+([\\s\\S]*?)(?=\\n###\\s+|\\n$)`,
                "m"
              );
              const m = body.match(re);
              return m ? m[1].trim() : null;
            }

            function getCheckedOptions(sectionTitle) {
              const block = getSection(sectionTitle);
              if (!block) return [];
              return block
                .split("\n")
                .map(l => l.trim())
                .filter(l => l.startsWith("- [x] "))
                .map(l => l.replace("- [x] ", "").trim());
            }

            async function ensureLabel(name) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name,
                    color: "c5def5",
                    description: "Auto-applied from issue form"
                  });
                } else {
                  throw e;
                }
              }
            }

            // ---------------- read form values ----------------
            const qaCategory = getSection("QA Category");      // dropdown
            const devices = getCheckedOptions("Device(s)");   // checkboxes
            const browsers = getCheckedOptions("Browser(s)"); // checkboxes

            // ---------------- mappings ----------------
            const qaMap = {
              "Functionality Testing": "qa:functionality",
              "Responsive and Cross-browser Testing": "qa:responsive-crossbrowser",
              "Accessibility": "qa:accessibility",
              "Load Testing": "qa:load"
            };

            const deviceMap = {
              "Mac Desktop / Laptop": "device:mac",
              "Windows Desktop / Laptop": "device:windows",
              "iPhone": "device:iphone",
              "Android Phone": "device:android-phone",
              "iPad": "device:ipad",
              "Android Tablet": "device:android-tablet"
            };

            const browserMap = {
              "Chrome": "browser:chrome",
              "Edge": "browser:edge",
              "Firefox": "browser:firefox",
              "Safari": "browser:safari"
            };

            const desired = new Set();

            if (qaCategory && qaMap[qaCategory]) desired.add(qaMap[qaCategory]);
            devices.forEach(d => { if (deviceMap[d]) desired.add(deviceMap[d]); });
            browsers.forEach(b => { if (browserMap[b]) desired.add(browserMap[b]); });

            const desiredLabels = Array.from(desired);

            // ---------------- authoritative mode ----------------
            // Remove any existing labels that start with these prefixes,
            // then apply the new "desiredLabels".
            const prefixes = ["qa:", "device:", "browser:"];

            const currentLabels = (context.payload.issue.labels || []).map(l => l.name);

            const toRemove = currentLabels.filter(name => prefixes.some(p => name.startsWith(p)));

            // Remove old scoped labels
            for (const name of toRemove) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number, name });
              } catch (e) {
                // If label was already removed or race condition, ignore 404
                if (e.status !== 404) throw e;
              }
            }

            // If nothing desired (e.g., headings didn't match), stop here.
            // This prevents accidentally wiping scoped labels and adding nothing.
            if (desiredLabels.length === 0) {
              core.warning("No desired labels found (check section titles). Leaving scoped labels removed.");
              return;
            }

            // Ensure labels exist
            for (const l of desiredLabels) await ensureLabel(l);

            // Apply desired labels
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number,
              labels: desiredLabels
            });

            core.info(`Removed scoped labels: ${toRemove.join(", ") || "(none)"}`);
            core.info(`Applied labels: ${desiredLabels.join(", ")}`);
